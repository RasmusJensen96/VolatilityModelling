## We use the solnp optimizer in the Rsolnp package to maximize the 
## log likelihood subject to nonlinear constraints.

## install the package
# install.packages("Rsolnp")

##load 
library(Rsolnp)
## 1) Simulation from GARCH

GARCHSim <- function(iT, dOmega, dAlpha, dBeta) {
  
  ## initialize the vector of simulated returns and variances
  vY = numeric(iT)
  vSigma2 = numeric(iT)
  
  ## initialize the variance at time t = 1 with its unconditional value
  vSigma2[1] = dOmega/(1.0 - dAlpha - dBeta)
  ## sample the first observations
  vY[1] = rnorm(1, mean = 0, sd = sqrt(vSigma2[1]))
  
  ##loop over iT. We start from t = 2 since t = 1 has already been sampled
  for (t in 2:iT) {
    #update the volatility
    vSigma2[t] = dOmega + dAlpha * vY[t - 1]^2 + dBeta * vSigma2[t - 1]
    #sample a new observarions
    vY[t] = rnorm(1, mean = 0, sd = sqrt(vSigma2[t]))
  }
  
  ## we return a list with two components: the sampled returns and the volatility
  lOut = list()
  lOut[["vY"]] = vY
  lOut[["vSigma2"]] = vSigma2
  
  ## output lOut
  return(lOut)
} 

## 2) Estimation

## Function to evaluate the likelihood and filtered volatiltiy 
## of a GARCH(1, 1) model
GARCHFilter <- function(vY, dOmega, dAlpha, dBeta) {
  
  ## number of observations
  iT = length(vY)
  
  ## initialize the variance
  vSigma2 = numeric(iT)
  
  ## set the variance at time t = 1 to the empirical variance of the first 0.1 * iT observations
  vSigma2[1] = var(vY[1:round(iT * 0.1)])
  
  # ## compute the log--likelihood of the first obs
  dLLK = dnorm(vY[1], 0, sqrt(vSigma2[1]), log = TRUE)
  # 
  ## loop over iT
  for (t in 2:iT) {
    # update the volatility
    vSigma2[t] = dOmega + dAlpha * vY[t-1]^2 + dBeta * vSigma2[t - 1]
    # add the log-likelihood contribution at time t
    dLLK = dLLK + dnorm(vY[t], 0, sqrt(vSigma2[t]), log = TRUE)
  }
  
  lOut = list()
  lOut[["dLLK"]] = dLLK
  lOut[["vSigma2"]] = vSigma2
  
  return(lOut)
  
}

## function to estimate a GARCH(1, 1) model

#we first code the objective function i.e. the negative log likelihood
#se specify a vector of coefficients to be estimated, the first coefficient
#is omega, the second is alpha, and the third is beta

ObjectiveFunction <- function(vPar, vY) {
  
  dOmega = vPar[1]
  dAlpha = vPar[2]
  dBeta  = vPar[3]
  dLLK = GARCHFilter(vY, dOmega, dAlpha, dBeta)$dLLK
  
  return(-dLLK)
}

## The inequality constraints to be satisfied to impose weak stationarity  
## are evaluated in the function ineqfun
## Note the use of the ellipsis ... due to the fact that ineqfun in solnp() should
## accepts all the arguments passed to the objective function
ineqfun_GARCH_WS <- function(vPar, ...) {
  dAlpha = vPar[2]
  dBeta  = vPar[3]
  
  return(dAlpha + dBeta)
}

## function to estimate the GARCH(1, 1) model. Note that the inequality constraint function
## is an argument and it is set to the ineqfun_GARCH_WS() function by default.
## The inequality lower and upper bound are identified by ineqLB and ineqUB, respectively.
## By default we specity ineqLB = 0.00 and ineqUB = 0.9999 in order to match
## 0 < ineqfun_GARCH_WS(vPar) < 0.9999, i.e. 0 < alpha + beta < 0.9999
EstimateGARCH <- function(vY, ineqfun_GARCH = ineqfun_GARCH_WS, ineqLB = 0.00, ineqUB = 0.9999) {
  
  # We set starting value for alpha equal to 0.05, dBeta = 0.94, and chose omega to target
  # the empirical variance by targeting the unconditional variance of the 
  # GARCH model
  
  dAlpha = 0.05 #
  dBeta  = 0.94
  dOmega = var(vY) * (1.0 - dAlpha - dBeta)
  
  ## vector of starting parameters
  vPar = c(dOmega, dAlpha, dBeta)
  
  # have a look at help(solnp)
  ##optimization step
  optimizer = solnp(vPar, fun = ObjectiveFunction, vY = vY,
                    ineqfun = ineqfun_GARCH, #the inequality constraint
                    ineqLB  = ineqLB, ## the inequality lower bound
                    ineqUB = ineqUB, ## the inequality lower bound, i.e. 0.0 < alpha + beta < 0.9999
                    ## lower and upper bounds for all parameters
                    LB = c(0.00001, 0.0001, 0.0001), UB = c(10.0, 0.999, 0.999)) 
  
  ## extract estimated parameters
  vPar = optimizer$pars
  
  ## extract the likelihood computed at its maximum
  dLLK = -tail(optimizer$values, 1)
  
  ## compute filtered volatility
  vSigma2 = GARCHFilter(vY, vPar[1], vPar[2], vPar[3])$vSigma2
  
  ## Compute the Average BIC
  iT = length(vY)
  BIC = (-2 * dLLK + log(iT) * length(vPar))/iT
  
  ## return a list with estimated parameters, likelihood value and BIC
  lOut = list()
  lOut[["vPar"]] = vPar
  lOut[["dLLK"]] = dLLK
  lOut[["BIC"]] = BIC
  lOut[["vSigma2"]] = vSigma2
  
  return(lOut)
}

#### Example 

set.seed(1234)

dOmega = 0.03
dAlpha = 0.04
dBeta = 0.95

iT = 1000

lSim = GARCHSim(iT, dOmega, dAlpha, dBeta)

vY = lSim$vY

Fit = EstimateGARCH(vY)

## the estimated prameters
Fit$vPar

## comparison between true and filtered volatility
plot.ts(lSim$vSigma2)
lines(Fit$vSigma2, col = "red")

### real data

library(quantmod)

# sTicker = "AAPL" #Apple
# sTicker = "MSFT" #Microsoft
sTicker = "BTC-USD" #Bitcoin vs USD

mPrices = getSymbols(sTicker, from = "1990-01-01", to = "2019-10-04", auto.assign = FALSE)

vY = as.numeric(diff(log(mPrices[, 6])))[-1] * 100

## Estimate the model assuming weak stationarity
Fit_WS = EstimateGARCH(vY)

## the estimated prameters
Fit_WS$vPar

## alpha + beta is very close to one
sum(Fit_WS$vPar[-1])

## comparison between true and filtered volatility
plot.ts(Fit_WS$vSigma2)

## If we want to just assume strict stationarity and not 
## weak stationarity the inequality constraint is
## E[log(alpha + beta * Z_t^2)] < 0. We can implement this
## constraint by numerical integration. 
## In this case the new inequality constraint is

ineqfun_GARCH_SS <- function(vPar, ...) {
  
  dAlpha = vPar[2]
  dBeta = vPar[3]
  
  ## Numerical counterpart of E[log(alpha + beta Z_t^2)]
  ## when the process is GARCH and the shocks are Gaussian.
  integrate(function(z, dAlpha, dBeta) {
    log(dAlpha + dBeta * z^2) * dnorm(z)
  }, lower = -10, upper = 10,
  dAlpha = dAlpha, dBeta = dBeta)$value
  
}

## Note that we change the inequality constraint and the relative bounds
Fit_SS = EstimateGARCH(vY, ineqfun_GARCH = ineqfun_GARCH_SS, ineqLB = -9999, ineqUB = -0.0001)

Fit_SS$vPar
Fit_WS$vPar

## the estimated prameters
sum(Fit_SS$vPar[-1])

Fit_SS$dLLK
Fit_WS$dLLK

plot.ts(sqrt(Fit_SS$vSigma2))

# Difference between the two estimated models
plot.ts(sqrt(Fit_SS$vSigma2) - sqrt(Fit_WS$vSigma2))




